@file:Suppress("INVISIBLE_REFERENCE")

package dev.schlaubi.tonbrett.cli.io

import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.staticCompositionLocalOf
import com.varabyte.kotter.foundation.defaultTerminalProviders
import com.varabyte.kotter.foundation.firstSuccess
import com.varabyte.kotter.foundation.input.CharKey
import com.varabyte.kotter.foundation.input.Key
import com.varabyte.kotter.foundation.input.Keys
import com.varabyte.kotter.platform.concurrent.locks.ReentrantLock
import com.varabyte.kotter.platform.concurrent.locks.withLock
import com.varabyte.kotter.runtime.internal.ansi.Ansi
import dev.schlaubi.tonbrett.cli.components.Content
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlinx.datetime.Clock
import kotlinx.datetime.Instant
import kotlin.time.Duration.Companion.milliseconds

val LocalKeyEvents = staticCompositionLocalOf<Flow<Key>> { throw UnsupportedOperationException("no default") }

@Suppress("INVISIBLE_MEMBER")
private val terminal = defaultTerminalProviders.firstSuccess()
private val keyEvents = collectKeys()

// Thank you very much to kotter:
// https://github.com/varabyte/kotter/blob/a38e5ec26c1d2e1a5cd9f0d1c2d54e535a3e1908/kotter/src/commonMain/kotlin/com/varabyte/kotter/foundation/input/InputSupport.kt#L52
private fun collectKeys(): SharedFlow<Key> {
    val keyLock = ReentrantLock()
    val escSeq = StringBuilder()
    var lastKeyTime: Instant
    return channelFlow {
        terminal.read().collect { byte ->
            val c = byte.toChar()
            val key = keyLock.withLock {
                lastKeyTime = Clock.System.now()
                when {
                    escSeq.isNotEmpty() -> {
                        // Normally, we get here if we're continuing an existing esc sequence, but if so some reason
                        // a previous one was never consumed *and* we are starting a new ESC sequence, just clear
                        // out anything left over from before. This could happen for example if the user just
                        // pressed ESC (which puts an ESC in the escSeq queue and waits a while before sending it
                        // out), but maybe also we end up getting an escape sequence that we didn't know how to
                        // handle, and without doing this, that old sequence would block us from working ever again.
                        if (c == Ansi.CtrlChars.ESC) escSeq.clear()

                        escSeq.append(c)
                        @Suppress("INVISIBLE_MEMBER")
                        val code = Ansi.EscSeq.toCsiCode(escSeq)
                        if (code != null) {
                            escSeq.clear()
                            when (code) {
                                Ansi.Csi.Codes.Keys.UP -> Keys.UP
                                Ansi.Csi.Codes.Keys.DOWN -> Keys.DOWN
                                Ansi.Csi.Codes.Keys.LEFT -> Keys.LEFT
                                Ansi.Csi.Codes.Keys.RIGHT -> Keys.RIGHT
                                Ansi.Csi.Codes.Keys.HOME, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_START -> Keys.HOME
                                Ansi.Csi.Codes.Keys.INSERT -> Keys.INSERT
                                Ansi.Csi.Codes.Keys.DELETE -> Keys.DELETE
                                Ansi.Csi.Codes.Keys.END, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_END -> Keys.END
                                Ansi.Csi.Codes.Keys.PG_UP -> Keys.PAGE_UP
                                Ansi.Csi.Codes.Keys.PG_DOWN -> Keys.PAGE_DOWN
                                else -> null
                            }
                        } else {
                            null
                        }
                    }

                    else -> {
                        when (c) {
                            Ansi.CtrlChars.EOF -> Keys.EOF
                            // Windows uses BACKSPACE, *nix uses DELETE? Best to support both
                            Ansi.CtrlChars.BACKSPACE, Ansi.CtrlChars.DELETE -> Keys.BACKSPACE
                            Ansi.CtrlChars.TAB -> Keys.TAB
                            Ansi.CtrlChars.ENTER -> Keys.ENTER
                            Ansi.CtrlChars.ESC -> {
                                escSeq.append(c)
                                // This is kind of ugly, but we need to detect the difference between the user
                                // pressing ESC on their own vs it being the first character in a chain of an escape
                                // sequence generated by the terminal. If the terminal generates an escape sequence,
                                // the whole thing is consumed sub millisecond, so waiting a couple dozen ms to be
                                // sure we aren't getting any followup characters. Note that a user can hold the
                                // keys down which generates a bunch of key signals, so we additionally make sure
                                // there hasn't been any other key pressed.
                                CoroutineScope(Dispatchers.IO).launch {
                                    val delay = 50.milliseconds
                                    var doneWaiting = false
                                    var sendEsc = false
                                    while (!doneWaiting) {
                                        delay(10.milliseconds)
                                        keyLock.withLock {
                                            if (Clock.System.now() - lastKeyTime > delay) {
                                                sendEsc = escSeq.length == 1 && escSeq.contains(Ansi.CtrlChars.ESC)
                                                if (sendEsc) escSeq.clear()
                                                doneWaiting = true
                                            }
                                        }
                                    }
                                    if (sendEsc) send(Keys.ESC)
                                }
                                null
                            }

                            else -> if (!c.isISOControl()) CharKey(c) else null
                        }
                    }
                }
            }

            if (key != null) {
                send(key)
            }
        }
    }
        // We only want to collect keypresses in one place per session. Use shareIn so collecters don't spawn new
        // flows. For example, multiple flows here would really mess with the escSeq logic
        .shareIn(CoroutineScope(Dispatchers.IO), SharingStarted.Lazily)
}

@Composable
fun ProvideKeyEvents(content: Content) {
    CompositionLocalProvider(
        LocalKeyEvents provides keyEvents,
        content = content
    )
}
